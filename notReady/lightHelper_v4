if (canvas.tokens.controlled.length === 0)
    return ui.notifications.error("Selecione o seu token");

const targets = Array.from(game.user.targets);
const tokenD = canvas.tokens.controlled[0];
const tokenName = token.actor.name
let largeFire = "-1 Large Fire / Torch / Sunset / Sunrise"
let twiLight = "-2 Twilights / Gaslight / Flashlight"
let deepTwilight = "-3 Deep Twilight / Candlelight"
let fullMoon = "-4 Full Moon"

// cont Pixi
const style = new PIXI.TextStyle({
    align: "center",
    breakWords: true,
    dropShadow: true,
    dropShadowDistance: 2,
    fill: "#ffc905",
    fontFamily: "Roboto",
    fontSize: 10,
    fontWeight: "bolder",
    strokeThickness: 4

});




let applyChanges = false;
new Dialog({
    title: `Ajudante de Mago Pregui√ßoso`,
    content: `
    <form>
      <div class="form-group">
        <label>Light Options: </label>
        <select id="lazylight" name="lazylight">
        <option value= 0 > Choose the lights </option>
        <option value= 1 > -1 Large Fire / Torch / Sunset/ Sunrise</option>
        <option value= 2 > -2 Twilights / Gaslight / Flashlight </option>
        <option value= 3 > -3 Deep Twilight / Candlelight</option>
        <option value= 4 > -4 Full moon</option>
      </select>
      </div>
    </form>
    `,
    buttons: {
        yes: {
            icon: "<i class='fas fa-check'></i>",
            label: `Confirm`,
            callback: () => (applyChanges = true),
        },
        no: {
            icon: "<i class='fas fa-times'></i>",
            label: `Cancel`,
        },
    },
    default: "yes",
    close: (html) => {
        if (applyChanges) {
            let updates = [];
            for (let token of canvas.tokens.controlled) {
                let lazyLight =
                    html.find('[name="lazylight"]')[0].value || "none";

                // Nenhum bucket escolhido

                switch (lazyLight) {
                    case "0":
                    default:
                        console.log(
                            "You choosed nothing"
                        );
                        break;

                    // -1 Large Fire / torch/ sunset/ sunrise

                    case "1":
                        let tokenD = canvas.tokens.controlled[0];

                        new Sequence()
                            .effect()
                            .atLocation(tokenD)
                            .name("texto")
                            .text(`${largeFire}`, style)
                            .spriteOffset({ x: 0, y: -40 })
                            .fadeIn(400, { ease: "easeOutCirc", delay: 200 })
                            .scaleIn(0, 500, { ease: "easeOutCubic", delay: 300 })
                            .fadeOut(400, { ease: "easeOutCirc", delay: -100 })
                            .scaleOut(0.1, 500, { ease: "easeOutCubic", delay: 300 })
                            .animateProperty("sprite", "position.y", { from: 40, to: -40, duration: 1800 })
                            .play()
                        GURPS.executeOTF(
                            `/sendmb ${tokenName}  [${deepTwilight}]`
                        );






                        break;

































                    // -2 Twilights / gaslight flashlight 
                    case "2":
                        GURPS.executeOTF(
                            `/sendmb ${tokenName}  ${deepTwilight}`
                        );

                        break;

                    //-3 Deep Twilight / candlelight
                    case "deepTwilight":
                        console.log(
                            `/sendmb ${tokenName}  ${deepTwilight}`
                        );

                        break;

                    //-3 Deep Twilight / candlelight
                    case "fulllmon":

                        GURPS.executeOTF(
                            `/sendmb ${tokenName}  ${fullMoon}`
                        );

                        break;
                }
            }
        }
    },
}).render(true);